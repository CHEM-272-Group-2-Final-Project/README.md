"""
272_Project 2  
David Houshangi  
Edited Yejin Yang's code  
All variables renamed - descriptive names. for clarity. 
itarations = 0, 2500, 5600


"""

import numpy as np
import matplotlib.pyplot as plt

# 1. Initial particle locations:

def PlotLocation(initial_position_radius=100, number_of_particles=100):
    Xinit = np.random.uniform(-initial_position_radius, initial_position_radius, (number_of_particles, 1))
    Yinit = np.random.uniform(-initial_position_radius, initial_position_radius, (number_of_particles, 1))
    return Xinit, Yinit

# 2. Define Lennard-Jones potential:

def Potential(Dx, Dy, a_repulsive_force=1, b_attractive_force=1, number_of_particles=100):
    pairwise_distance = np.sqrt(Dx ** 2 + Dy ** 2)

    # To avoid error (zero division):
    
    eps = 1e-10
    identity_matrix = np.eye(number_of_particles)
    pairwise_distance = pairwise_distance + identity_matrix * (1 / eps)

    # LJ Equation:

    Phi = (a_repulsive_force / pairwise_distance ** 12) - (b_attractive_force / pairwise_distance ** 6)
    np.fill_diagonal(Phi, 0)
    return Phi

# 3. Calculate total potential for each particle:

def DisToPotential(Xinit, Yinit, a_repulsive_force, b_attractive_force, number_of_particles, identity_matrix, Ones):
    Xi_tile = np.tile(Xinit, (1, number_of_particles))
    Yi_tile = np.tile(Yinit, (1, number_of_particles))

    Dx = Xi_tile - Xi_tile.T
    Dy = Yi_tile - Yi_tile.T

    Phi = Potential(Dx, Dy, a_repulsive_force, b_attractive_force, number_of_particles)
    Utot = np.dot(Phi, Ones)
    return Utot

# 4. Metropolis Monte Carlo move for all particles:

def MoveParticle(Xinit, Yinit, number_of_particles = 100, number_of_iterations = 1000, a_repulsive_force = 1, b_attractive_force = 1, temperature = 1, delta = 1):
    identity_matrix = np.eye(number_of_particles)
    Ones = np.ones((number_of_particles,))

    for iteration in range(number_of_iterations):
        for i in range(number_of_particles):
            dx = delta * np.random.choice([-1, 1])
            dy = delta * np.random.choice([-1, 1])

            Xtri = np.copy(Xinit)
            Ytri = np.copy(Yinit)

            Xtri[i] += dx
            Ytri[i] += dy

        # 100 - +100 boundaries:

            Xtri[i] = np.clip(Xtri[i], -100, 100)
            Ytri[i] = np.clip(Ytri[i], -100, 100)

            U_old = DisToPotential(Xinit, Yinit, a_repulsive_force, b_attractive_force, number_of_particles, identity_matrix, Ones)[i]
            U_new = DisToPotential(Xtri, Ytri, a_repulsive_force, b_attractive_force, number_of_particles, identity_matrix, Ones)[i]
            dU = U_new - U_old

            rho = np.random.rand()
            if dU < 0 or rho < np.exp(-dU / temperature):
                Xinit[i] = Xtri[i]
                Yinit[i] = Ytri[i]

        # Plotting only at specific iterations (0, 2500, and 5600):

        if iteration in [0, 2500, 5600]:
            plt.scatter(Xinit, Yinit, c = 'gray')
            plt.xlabel('x_direction')
            plt.ylabel('y_direction')
            plt.title(f'After {iteration} iterations: temperature = {temperature}, a (Repulsive_force) = {a_repulsive_force}, b (Attarction_force) = {b_attractive_force}')
            plt.grid(True)
            plt.xlim(-100, 100)
            plt.ylim(-100, 100)
            plt.gca().set_aspect('equal')

            plt.show()

# 5. Simulation class:

class SimulateParticles:
    def __init__(self, number_of_particles = 100, initial_position_radius = 100):
        self.number_of_particles = number_of_particles
        self.initial_position_radius = initial_position_radius
        self.Xinit, self.Yinit = PlotLocation(initial_position_radius, number_of_particles)

    def run(self, number_of_iterations = 1000, a_repulsive_force = 1, b_attractive_force = 1, temperature = 1, delta = 1):
        MoveParticle(self.Xinit, self.Yinit, self.number_of_particles, number_of_iterations, a_repulsive_force, b_attractive_force, temperature, delta)



# Run 1:
# Room temperature = 25, a = 1, b = 1, Number of particles = 6000:

sim = SimulateParticles(number_of_particles = 200, initial_position_radius = 100)
sim.run(number_of_iterations = 6000, a_repulsive_force = 1, b_attractive_force = 1, temperature = 25)
